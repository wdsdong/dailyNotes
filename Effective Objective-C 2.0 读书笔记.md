##Effective Objective-C 2.0 读书笔记


##熟悉 Objective-C

###一、了解 Objective-C语言的起源
* Objective-C为 C 语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，在运行时才会检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定

* 理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针
	
###二、在类的头文件中尽量少引入其他头文件
* 除非有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入哪些类的头文件。这样做可以尽量减低类之间的耦合（coupling）

* 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把‘该类遵循某协议’的这条声明移至‘class-continuation分类’中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入

###三、多用字面量语法(literal syntax)，少用与之等价的方法
* 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要

* 应该通过取下标操作来访问数组下标或字典中的键所对应的元素

* 用字面量语法来创建数组或字典时，若值为 nil,则会抛出异常。因此，务必确保值里不含 nil

###四、多用类型常量，少用#define 预处理指令
* 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找和替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致

* 在实现文件中使用 static const 来定义“只在编译单元内可见的常量（translation-unit-specific constant）”。由于此类常量不在全局符号表中，所以无须为其名称加前缀

* 在头文件中使用 extern 来成名全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以曲隔，通常用与之相关的类名做前缀

###五、用枚举表示状态、选项、状态码
* 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字

* 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来

* 用 NS_ENUM 于 NS_OPTIONS宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型

* 在处理枚举类型的 switch 语句语句中不要实现 default 分支。这样的话，加入新枚举之后编译器就会提示开发者：switch 语句并未处理所有枚举


##对象、消息、运行期                                                                                   

###六、理解“属性”这一概念
* 可以用@Property 语法来定义对象中封装的数据

* 通过“特质”来指定存储数据所需的正确语义

* 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义

* 开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能

###七、在对象内部尽量直接访问实例变量
* 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写

* 在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据

* 有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据

###八、理解“对象等同性”这一概念
* 若想检测对象的等同性，请提供“isEqual”与“hash”方法

* 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同

* 不要盲目地逐个检测每条属性，而是应该依照具体需求来指定检测方案

* 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的方法

###九、以“类族模式”隐藏实现细节
* 类族模式可以把实现细节隐藏在一套简单的公共接口后面

* 系统框架中经常使用类镞（NSString，NSArray，NSDictionary，NSNumber）

* 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读

###十、在既有类中使用关联对象存放自定义数据
* 可以通过“关联对象”机制来把两个对象连起来

* 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”

* 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难与查找的 bug

##内存管理
 
###二十九、理解引用计数
* 引用计数机制通过可以递增递减的计数器来管理内存。对象创建之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了

* 在对象声明周期中，其余对象通过引用来保留或释放对象。保留和释放操作会被递增及递减保留计数

###三十、以 ARC 简化引用计数
* 在 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可省去类中去多的“样板代码”

* ARC 管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作

* 由方法所返回的对象，其内存管理语义总是通过方法名来实现。ARC 将此确定为开发者必须遵守的规则

* ARC 只负责管理 Objective-C 对象的内存。尤其要注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain/CFRelease

###三十一、在 dealloc 方法中只释放引用并解除监听
* 在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观察”（KVO）或 NSNotificationCenter 等通知，不哟啊做其他事情

* 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用 close 方法

* 执行异步任务的方法不应在 dealloc 里调用；只能在正常状态下执行的那些方法也应在 dealloc 里调用，因为此时对象已处于正在回收的状态了

###三十三、以弱引用避免保留环
* 将某些应用设为 weak，可避免出现“保留环”

* weak 引用可以自动清空，也可以不自动清空。自动清空是随着 ARC 而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收的对象

###三十四、以“自动释放池块”降低内存峰值
* 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里

* 合理运用自动释放池，可降低应用程序的内存峰值

* @autorelease 这种新式写法能创建出更为轻便的自动释放池

###三十五、用“僵尸对象”调试内存管理问题
* 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombieEnabled 可开启此功能

* 系统会修改对象的 isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序

###三十六、不要使用 retainCount
* 对象的暴力计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”都无法反映对象生命期的全貌

* 引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错

##块与大中枢派发

###三十七、理解“块”这一概念
* 块是 C、C++、Objective-C 中的此法闭包

* 块可接受参数，也可返回值

* 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的Objective-C 对象一样，具备引用计数了

###三十八、为常用的块类型创建 typedef
* 以 typedef 重新定义块类型，可令块变量用起来更加简单

* 定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突

* 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应 typedef 中的块签名即可，无需改动其他 typedef

###三十九、用 handler 块降低代码分散程度
* 在创建对象时，可以使用内嵌的 handler块将相关业务逻辑一并声明

* 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起

* 设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行


###四十、用块引用其所属对象时不要出现保留环
* 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题

* 一定要找个适当的时机就出保留环，而不能把责任推给 API 的调用者

###四十一、多用派发队列，少用同步锁
* 派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized 块或 NSLock 对象更简单

* 将同步与异步派发结合起来，可以实现与普通加锁技术机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程

* 使用同步队列及栅栏块，可以令同步行为更加高效

###四十二、多用 GCD，少用 performSelector 系列方法
* performSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法

* performSelector 系列方法所能处理的选择自太过局限了，选择子的返回值类型器及发送给方法的参数个数都收到限制

* 如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现

###四十三、掌握 GCD 及操作队列的使用时机
* 在解决多线程与任务管理问题时，派发队列并非唯一方案

* 操作队列提供了一套高层的 Objective-C API，能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码

###四十四、通过 Dispatch Group 机制，根据系统资源状况来执行任务
* 一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知

* 通过 dispatch group，可以在并发式派发队列里同事执行多项任务。此时 GCD 会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码

###四十五、使用 dispatch_once 来执行只需运行一次的线程安全代码
* 经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过 GCD 所提供的 dispatch_once 函数，很容易就能实现此功能

* 标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的

###四十六、不要使用 dispatch_get_current_queue

##系统框架

###四十七、熟悉系统框架
* 许多系统框架都可以直接使用。其中最重要的是 Foundation 与 CoreFoundation，这两个框架提供了构建应用程序所需的去多核心功能

* 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等

* 请记住：用纯 C 写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C语言的核心概念

###四十八、多用块枚举，少用 for 循环
* 遍历 collection 有四种方式。最基本的额办法是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新、最先进的方式则是“块枚举法”

* “块枚举法”本身就能通过 GCD 来并发执行遍历操作，无需另行编写代码。而采用其他遍历方式则无法轻易实现这一点

* 若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型