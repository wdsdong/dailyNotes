##堆和栈

数据结构中的堆和栈

Heap（堆）和 Stack（栈）

堆：

栈：只能允许在链接串列或阵列的一端进行 push 和输出数据 pop.(LIFO)


内存分配中的堆和栈

**堆栈空间分配**

栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能有 OS 释放，分配方式倒是类似于链表

**内存的五大区域**

栈：局部变量，函数的参数值 --向下增长
 
堆：分配程序员申请的内存空间 --向上增长

BSS 段：未初始化的局部变量，静态变量

数据段：已初始化的局部变量，静态变量

代码段：存放程序和常量


##引用计数

计算机编程语言中的一种内存管理计数，是指将资源（可以是对象、内存或磁盘空间等等）的背引用次数保存起来，当被引用次数变为0时就将其释放的过程。实现自动资源管理的目的。

```
当程序调用方法名以 alloc/new/copy/mutableCopy 开头的方法来创建对象时，该对象的引用计数加1
程序调用对象的 retain 方法时，该对象的引用计数加1
程序调用对象的 release 方法时，该对象的引用计数减1
```

NSObject 中提供了有关引用计数的如下方法：

* retain：将对象的引用计数器加1
* release：将对象的引用计数器减1
* autorelease：不改变对象的引用计数器的值，只是将对象添加到自动释放池中
* retainCount：返回该对象的引用计数的值

引用计数内存管理的思考方式：

* 自己生成的对象，自己持有
* 非自己生成的对象，自己也能持有
* 不再需要自己持有的对象时释放
* 非自己持有的对象无法释放


|对象操作     |Objective-C 方法|
|------------|---------------|
|生成并持有对象|alloc/new/copy/mutableCopy|
|持有对象     |retain|
|释放对象     |release|
|废弃对象     |dealloc|


##ARC 内存泄露常见场景

一、对象型变量作为 C 语言结构体（struct、union）的成员

二、循环引用

2.1.两个对象互相持有对象，这个可以设置若引用解决

2.2block 持有 self对象，这个要在 block 块外面和里面设置弱引用和强引用
2.3NSTimer 的 target持有 self
NSTimer会造成循环引用，timer会强引用target即self，一般self又会持有timer作为属性，这样就造成了循环引用。
那么，如果timer只作为局部变量，不把timer作为属性呢？同样释放不了，因为在加入runloop的操作中，timer被强引用。而timer作为局部变量，是无法执行invalidate的，所以在timer被invalidate之前，self也就不会被释放。

三、单例属性不释放